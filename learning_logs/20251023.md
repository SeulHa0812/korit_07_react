# Login Process 진행
# REST API 호출
현재 상황에서 로그인을 성공한다고 하더라고 jwt를 세션 스토리지에 저장했을 뿐이고, 아직 getcars()의 결과값을 가져오지는 못함.

이 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지고 frontend 상에서 Carlist를 불러오지 못하고 있는 상황이기 때문임.

carapi.ts에 getCars() 호출을 할 때 얻어온 jwt를 사용해야 하기 때문임.
근데 jwtToken 값이 생각해보면 .then()에 걸려있기 때문에 일종의 지역변수라고 볼 수 있음. 그렿다면 Login 컴포넌트를 벗어나서는 사용할 수 없다는 의미가 될 것임.
그러면 얘를 어떻게 끌고 와서 getCars() 함수에 jwt 값을 넣어서 같이 GET 요청을 보낼 수 있을지 고민해볼 것.

sesstionStorage에 굳이 setItem을 한 이유 ?
-> carapi.ts에서 쓰기 위해

그래서 api들에 token 집어넣는거 하고나서는 중복 코드를 리팩토링할 예정.
지금 보면 결과적으로 token을 함수들에서 전부 다 꺼내쓰고 있는 중인데다가 Authorization : token 이런 부분이 반복적으로 쓰이는 것 확인 가능.

```tsx
// api/carapi.ts 파일 생성
import axios from "axios";
import { CarResponse, Car } from "../types";
import { CarEntity } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');
    // 세션 스토리지 상에 'Bearer '가 포함되어있음. 근데 Postman에서 요청 날릴 때 'Bearer ' 부분 빼놓고 붙여넣기 했었던 것을 떠올려서
    // 프론트 엔드 상에서 'Bearer '를 제거하고, 그걸 기준으로 요청 날림.
    const rawToken = token?.replace('Bearer ', '');
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
        headers: { 'Authorization': rawToken }
      });

    return response.data._embedded.cars;
  }

export const deleteCar = async (link: string) : Promise<CarResponse[]> => {
  const token = sessionStorage.getItem('jwt');
  const rawToken = token?.replace('Bearer ', '');
  const response = await axios.delete(link, {
        headers: { 'Authorization': rawToken }
      });
  return response.data 
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
  const token = sessionStorage.getItem('jwt');
  const rawToken = token?.replace('Bearer ', '');
  const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': rawToken
    },
  });

  return response.data;
}

export const updateCar = async (carEntity: CarEntity) : Promise<CarResponse> => {
  // chaining mehtod 사용 예시
  const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');
  const response = await axios.put(carEntity.url, carEntity.car, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': token
    },
  });
  return response.data
}
```
이상은 refactoring 전 부분임. 위에 말했던 것처럼 token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를 제거하는 부분, 그리고 headers 내에 'Authorization': token 부분이 중복되고 있다는 것 확인 가능.

이 부분에서 알아야 할 점은 Scope 개념.
각 함수의 내부에서 token을 선언하고 Bearer 접두사를 제거하고 있기 때문에 함수 마다 선언 및 초기화를 하는 것 같음.

## 중복 코드 리팩토링
```ts
import axios, { AxiosRequestConfig } from "axios";
import { CarResponse, Car } from "../types";
import { CarEntity } from "../types";

const getAxiosConfig = () : AxiosRequestConfig => {
  const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');
  return {
    headers: {
      'Authorization': token,
      'Content-Type': 'application/json',
    },
  };
};

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, getAxiosConfig());

    return response.data._embedded.cars;
  }

export const deleteCar = async (link: string) : Promise<CarResponse[]> => {
  const response = await axios.delete(link, getAxiosConfig());

  return response.data 
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
  const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, getAxiosConfig());

  return response.data;
}

export const updateCar = async (carEntity: CarEntity) : Promise<CarResponse> => {
  const response = await axios.put(carEntity.url, carEntity.car, getAxiosConfig());
  
  return response.data
}
```
이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig.

- AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때 사용되는 구성 객체 타입 정의에 해당. 죽, Axios를 경우하여 요청을 보내기 위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당.

- axios.post(), .get ...과 같은 방식으로 사용함. 이는 좀 더 가독성을 높이기 위한 방식으로 _메서드  별 요청_ 에 해당함. 이 경우 endpoint 다음에 두 번째 argument로 사용됨.
1. 메서드 별 요청
```ts
// GET 요청이라고 가정
axios.get('http://localhost:8080/api/cars', {headers:{'Authorization':token}});
```
2. 일반적인 요청 방식
```ts
axios({
  method: 'get',
  url: 'http://localhost:8080/api/cars',
  headers: {
    'Authorization': token,
  }
});
```
이상의 1, 2 과정 중에 return 타입에 객체 형태로 옵션들을 담을 수 있는 것을 AxiosRequestConfig라고 함. 우리는 1번 방법 사용했기 때문에 getAxiosConfig() 함수의 정의가 간단한 편에 속함. 2 번 방법이면 method 키의 value를 지정하는데 복잡함.

인터셉터(interxeptor)에서의 활용 : request interceptor는 요청이 서버로 가기 전에 가로채서 구성을 수정함.  즉 getAxiosConfig() 함수 요청을 하게 되면 처음에는 token이 없는 상태로 DB까지 가게 될 뻔했는데, 얘가 중간에 가로채서 headers를 추가해준다는 의미가 되겠음.

## Authentication 실패 시 오류 메시지를 토스트 메시지로 응용
```tsx
<Snackbar
  open={open}
  autoHideDuration={3000}
  onClose={() => setOpen(false)}
  message='ID 혹은 비밀번호가 틀렸습니다.'
/>
```
라고 설정을 했다고 가정했을 때, setOpen(true)를 호출하는 부분이 필요.
Login 컴포넌트 중 어떤 동작을 했을 때 toast message가 출력되어야하며, 그래서 setOpen(true) 코드를 삽입해야 하는 부분은 어디인가?

## shoppinglist의 Backend
- Spring Initializr
## todolist의 Frontend
- vite project 생성





