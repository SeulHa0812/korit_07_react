## TS로 리액트 앱 만들기
아까 위에 작성한 예시 코드들을 적용한 tsx를 작성하겠음.
```tsx
import './App.css'
import { useState } from 'react';

function App() {
  const [name, setName] = useState('');

  const handleChange = (event : React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value);
  }

  const handleSubmit = (event : React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    alert(`Hello ${name}`);
  }


  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" value={name} onChange={handleChange}/>
        <input type="submit" value="제출"/>
      </form>
    </>
  )
}

export default App;
```

# React RESTful API 구현
리액트를 이용한 네트워킹 실습 예정. cardatabase를 기준으로 다양한 react 적용 기술들을 jsx / tsx로 구현할 것이고, 이를 위해서 특히 네트워킹 파트에 fetch 및 axios 실습. 이는 비동기 코드를 더 깔끔하고 가독성있게 만들 수 있는 Promise 개념에 대해서 사전 학습이 되어있어야만 가능함.

Promise 역시도 js에 딸려있는 기능 중 하나였지만 그때는 설명하지 않았음.

react-query를 라이브러리를 이용하여 실제로 작동이 어떤식으로 이루어지는지에 대한 설명도 할 예정임.

## ts 프로젝트 생성
1. weatherapp - react - jsx 형태로 생성
2. App.jsx를 초기화
3. npm run dev

## Promise
- 비동기 연산을 처리하는 방법으로, 전통적인 방법은 연산의 성공 또는 실패에 대한 callback function을 작성해두는 것.
예를 들어 GET 요청을 했다고 가정했을 때, 이에 성공했다면 sucess() 함수를 호출하고, 실패했을 때는 failure() 함수를 호출하는 것처럼.
이하는 이를 추상적으로 작성한 예시
```js
function doAsynCall(success, failure) {
  // 어떤 API 호출

  if(SUCCEED) {
    success(resp);
  } else {
    failure(err);
  }
}
function success(response) {
    // 응답을 가지고 작업 수행
  }

function failure(error) {
    // 오류를 처리하는 로직
  }
```

이상은 예전에 이런 구조로 작성했었다라는 의미. 현재의 Promise는 JS에서 비동기 프로그래밍의 기본 요소기 때문에 Promise를 기반으로 한 코딩을 하게 됌.
그러면 Promise란?
-> 비동기 연산의 결과를 나타내는 JS 객체

이를 이용하면 비동기 호출을 실행할 때 코드가 좀 단순화됨. 얘가 없던 시절에는 코드를 읽고 유지 관리하는게 엄청 골치아팠었음. 여러 개의 중첩된 callback function들이 있어야만 했기 때문.

요청을 전송하는 데 이용하는 API 또는 라이브러리가 프로미스를 지원하는 경우, 프로미스를 이용한 비동기 호출을 실행할 수 있음.(오늘날에는 대부분 지원함). 이하에서는 비동기 호출 수행 관련 예제임.

```js
doAscyCall().then(response => 로직);
```
즉, 아까 위에위에 js 함수 정의를 했던 부분들 중에, doAscyCall()의 내부에서 if절 부분이 다 필요 없어지는 작성 방식이라고 할 수 있음.

이상의 호출 부분을 해석하기 위해서는 method의 결과가 return되고, 이것이 다음 .then() 메서드를 실행하는 객체가 된다는 점을 이해하고, builder 패턴에서 처음 배웠던 chaining mehtod 개념이 익숙하다면 충분히 해석할 수 있음.

응답이 반환됐을 때, then() 메서드 내부에 callback 함수가 실행되어 응답을 argument로 받게 됨(그래서 예시에 response라는 매개변수 명을 달아놓음).

그렇다면 여기서 의문을 가져야 하는 점은 then() 메서드의 return 자료형.

then() 메서드의 return 자료형 : Promist.
그리고, 이 Promist는 세 가지 상태 중 하나에 속함.
1. 대기(Pending) : 초기 상태
2. 이행(Resolved) : 작업 성공
3. 거부(Rejected) : 작업 실패

이하의 예시는 프로미스를 단순화시킨 형태로, 특히 setTimeout을 활용하여 비동기 연산을 시뮬레이션 했음.
```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello');
  }, 500);
});
```
1. JS에서도 생성자를 통한 객체 생성이 가능함. 즉, 95 번 라인에서는 myPromise라는 객체를 생성했다고 볼 수 있음.
2. 해당 myPromise 객체는 resolve 매개변수와 reject 매개변수를 가짐.
3. 프로미스 객체가 생성될 때와, 타이머가 실행되는 동안 프로미스는 _대기 상태_에 있음.
그리고 500 밀리초가 지나면 'Hello'라는 값으로 resolve 함수가 호출되고, 프로미스는 _이행_ 상태로 감. 오류가 발생하면 _거부_ 상태로 넘어감. 현재는 _거부_ 에서 처리하는 로직을 작성하지 않음.

그리고 이상에서 배웠던 .then() 메서드를 통해 인스턴스를 서로 연결하여 다수의 비동기 작업을 _순차적으로_ 진행시키는 것이 가능함. 
```js
doAsyncCall()
.then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행)
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
```
그리고 rejected된 상태에서의 오류 처리를 추가하는 것이 가능함.
```js
doAsyncCall()
.then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행)
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
.catch(error => console.log(error));
```
그러면 Java에서 배웠던 예외처리 방법에서처럼 doAscyCall()과 두 개의 .then() 메서드들 중에서 어디에서라도 오류/예외가 발생하면 catch 부분으로 넘어가게 됨.

개발자는 콘솔에 찍힌 error를 보고 이를 수정하게 될 것임.

## async / await
비동기 호출을 처리하는 좀 더 최신 방식은 ECMAScript2017에 도입된 async/await을 이용하는 방식.
이는 Promist에 대한 개념을 알고 있다는 전체 하에 사용하는 것이 정신건강에 좋음.
얘를 쓰려면 await 표현식을 포함할 수 있는 async() 함수를 정의해야함.

이하는 async / await의 비동기 호출 예시
```jsx
const doAsyncCall = async () => {
  const response = await fetch('http://someapi.com');
  const data = await response.json();
  // 그리고 data를 가지고 로직 수행하는 부분 정의
}
```
여기서 fetch() 함수가 나오는데, 얘의 return 값도 Promise임. 다만, async / await을 도입했을 경우 .then()을 쓰는 것이 아니라 await 키워드를 써야 함.

그리고 오류 처리를 위해서 마찬가지로 async / await에 try-catch문을 쓸 수도 있음. 이하는 그 예시.
```js
const doAsycCall = async () => {
  try {
    const response = await fetch('http://someapi.com');
    const data = await response.json();
    // data를 가지고 추가적인 비지니스 로직 정의
  }
  catch {
    console.log(error);
  }
}
```
이상까지가 전반적인 Promise의 정의와 사용 최근 사례
이를 이용하면 React 앱에서 request 작업에서 사용하는 fetchAPI에 대해서 학습할 준비가 된 것.


## fetch API 이용
JS 상에서의 fetch API 개념은 기존의 XMLHttpREquest 혹은 jQuery Ajax API와 유사, fetch API가 좋은 점은 Promise를 지원한다는 점.
그리고 react 내장 API라서 추가적인 설치가 필요없다는 점도 장점.

fetch API는 아까 위에서 봤던 fetch() 메서드를 제공함. 웹 요청의 경우에 argument는 서비스의 URL이 됨. 
그래서 이제 처음으로 _GET 요청_ 을 react에서 하는 예시 작성할 것.
```jsx
fetch('http://someapi.com')
.then(response => response.json())
.then(data => console.log(date))
.catch(error => console.log(error));
```
fetch() 메서드는 response가 포함된 프로미스를 return함. 이를 .json() 메서드를 활용하여 JSON 데이터를 추출하고, 이 메서드 역시 프로미스를 반환함(아꺄 위에 적었음, then 메서드의 결과값).

이상의 의사 코드에서 163 번 라인의 then 문에 전달되는 response는 요청이 성공했는지 확인하는 데 이용하는 ok 및 status 속성을 포함하는 객체임. 
응답 상태가 2xx 형식이라면 ok 값 속성을 true로 return됨.
```jsx
fetch('http://someapi.com') // 얘가 성공적으로 fetch가 이루어졌다면 response라는 애가 결과값으로 나오고
.then(response => { // 그 response를 가지고 연산을 하겠단느 의미로 해석하면 됨.
  if(response.ok) {
    // 요청 성공 -> 상태 2xx
  }
  else {
    // 문제 발생 -> 오류 응답(401, 404, 500 etc)
  }
})
.then(data => console.log(date))
.catch(error => console.log(error))
```
POST와 같은 다른 HTTP 메서드를 이용하려면 fetch() 메서드의 두 번째 argument에 해당 메서드를 정의해야 함. 두 번째 argument는 여러 요청 설정을 정의할 수 있는 _객체_ 임. 그래서 이하의 예시는 POST 요청에 대한 부분.

```jsx
fetch('http://someapi.com', {method: 'POST'})
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error))
```
근데 postman에서 해봤던 것처럼 특정한 자격이 있거나 특정 형식으로 headers를 추가할 필요가 있었음.
그럼 fetch()의 두 번째 argument인 객체에 key-value properties를 추가함으로써 해결할 수 있음.
이하의 예시는 Content-Type : application/json 헤더를 추가해보도록 할 것.
```jsx
fetch('http://someapi.com', 
  {
    method: 'POST',
    headers: {'Content-Type': 'application/json'}
  }) // postman에서 작업했던 부분
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error))
```
요청 본문 내에 KSON으로 인코딩된 데이터를 보내는 경우
```jsx
fetch('http://someapi.com', 
  {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(data)
  }) // postman에서 작업했던 부분
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error))
```

대충 나중에 복습할 fetchAPI가 복잡하다는 것은 알텐데, 얘가 또 유일하게 요청을 수행하는 방법인건 아님.
다수의 경우에는 axios라는 외부 라이브러리 활용.

## axios 라이브러리 이용
axios는 fetchAPI처럼 네트워크 호출과 관련된 라이브러리임. 즉, POST / GET / PUT / DELETE와 관련있음

- 여기서 특정 라이브러리를 사용하게 될 경우 추가 설치를 해야할 경우가 있음.
npm install axios -> node_modules에서 설치되었는지 확인 가능

axios 라이브러리에는 JSON 데이터의 자동 변환과 같은 이점을 지니고 있음. 그래서 fetch()에서 response.json() 메서드를 호출했던 것과 같은 과정이 필요없음.

```jsx
axios.get('http://someapi.com')
.then(response => console.log(response)) // fetch API를 썼을 때보다 then 절 하나가 줄었음.
.catch(error => console.log(error));
```

POST 요청을 할 때는 axios.post() 사용
```jsx
axios.post('http://someapi.com', { 어떤 새로운 객체 })
.then(response => console.log(response))
.catch(error => console.log(error));
```
axios() 함수를 이용하게 되면 method / headers / data / url 등의 세부 정보를 지정하는 객체를 전달하는 것도 가능함.

```jsx
const response = await axios({
  method: 'POST',
  url: 'https://myapi.com/api/cars',
  headers: {
    'Content-Type': 'application/json'
  },
  data: { brand: '현대', model: 'GV80' }
});
```
그래서 이상의 예시는 'https://myapi.com/api/cars' 엔트포인트로 POST 요청을 보내는데, 요청 본문에 객체가 포함되고, Axios가 자동으로 이를 문자열화(stringify)해줌.

## 실전 예제 weatherapp
### OpenWeather API 도입
https://openweathermap.org

RESTful API를 이용하는 경우 응답을 검사하여 JSON 데이터의 포맷을 확인해야 함. 즉, 날씨 정보를 OpenWeather API로 활용할 것.

https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=165381779c11113e4a8274dd8826248f

https://openweathermap.org/img/wn/04d@2x.png
여기서 04d가 icon key의 value로 잡혀있고, img 파일을 불러오기 위해서는 @2x.png을 붙여줘야 함.

```jsx
import { useState } from 'react';
import { useEffect } from 'react';
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
    icon: ''
  });

  useEffect(() => {
    fetch('https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=165381779c11113e4a8274dd8826248f')
    .then(response => response.json())
    .then(result => {
      setWeather({
        temp: result.main.temp,
        desc: result.weather[0].description,
        icon: result.weather[0].icon
      })
    })
  }, []);

  if(weather.icon) {
  return (
    <>
      <p>기온 : {weather.temp}</p>
      <p>설명 : {weather.desc}</p>
      <img src={`https://openweathermap.org/img/wn/${weather.icon}@2x.png`} alt="날씨 아이콘" />
    </>
  );
  } else {
    return <div>Loading ...</div>
  }
}

export default App;
```
이상의 코드에서 유념해야 봐야 할 점
1. useState()의 초기값으로 JS 객체 형태를 넣었다는 점 -> user 객체 형태로 firstName / lastName / email을 통해서 작성하는 방법을 수업했었음.
  - 이 부분이 번거로우면 각각의 상태를 선언하는 방식으로 작성함.

2. useEffect()의 argument 분석.
  - 1st argument는 callback function
  - 2nd argument는 어느 시점에 리렌더링을 할 것인가 통제. []의 의미도 알 필요가 있음.
  - callback function의 내부 로직은 fetchAPI 활용(axios가 아니라)
  - fetchAPI를 이해하기 위해서는 Promise 개념에 대한 선행이 요구됨.

3. useEffect()가 최초 렌더링 시에 호출이 되었고, 그 결과 callback function이 호출되면, weather이라는 상태가 업데이트 되었을 것.
  - 이를 확인하기 위한 방법으로 브라우저에서 개발자도구를 열고 Components 탭에서 State를 확인할 수 있었음.
  - 또한 실패했다면 Network 탭에서 200 ok가 아니라 오류 메시지가 떴거나,
  - 작성한 console.log(error)로 인해서 콘솔 창에 오류 메시지가 떴음.

4. 상태가 업데이트 되었음을 확인했다면, 이를 브라우저에 표시해주기 위해 return을 작성함.
  - icon이 img 파일이기 때문에 loading 시간이 가장 길 것이라고 판단, 그래서 icon의 유무에 따라서 조건문 작성을 통해 return 부분을 표시함.


### Github API 도입
1. githubapp 프로젝트 생성
2. App.jsx 초기화
3. npm run dev